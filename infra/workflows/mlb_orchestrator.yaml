# MLB Orchestrator (Google Cloud Workflows)
# - Input: {"team_id": 112, "date": "YYYY-MM-DD" (optional)}
# - Logic:
#   1) Resolve target date (explicit or "today" in America/New_York)
#   2) Fetch schedule for team/date
#   3) For each game: sleep until start -> +90 min -> poll status
#   4) When FINAL: run mlb-ingest -> sleep >=120s -> run mlb-digest

main:
  params: [input]
  steps:
    # ------------------ Init & validation ------------------
    - init:
        assign:
          - project_id: ${sys.get_env("GOOGLE_CLOUD_PROJECT_ID")}
          - region: ${sys.get_env("GOOGLE_CLOUD_LOCATION")}
          - east_tz: "America/New_York"
          - team_id: ${input.team_id}
          - date_str: ""
    - require_team_id:
        switch:
          - condition: ${team_id == null}
            steps:
              - fail_no_team:
                  raise: "team_id is required"

    # ------------------ Resolve date ------------------
    - set_date_try:
        try:
          steps:
            - use_input_date:
                assign:
                  - date_str: ${string(input.date)}
        except:
          as: e
          steps:
            - compute_today_et:
                assign:
                  - date_str: ${ text.substring(time.format(sys.now(), east_tz), 0, 10) }

    # ------------------ Fetch schedule ------------------
    - fetch_schedule:
        call: http.get
        args:
          url: https://statsapi.mlb.com/api/v1/schedule
          query:
            sportId: "1"
            teamId: ${string(team_id)}
            date: ${date_str}
        result: sched

    # ------------------ Extract games safely ------------------
    - init_games:
        assign:
          - games: []
    - set_games_if_any:
        switch:
          - condition: ${ len(sched.body.dates) > 0 }
            steps:
              - assign_games:
                  assign:
                    - games: ${sched.body.dates[0].games}
    - free_sched:
        assign:
          - sched: null

    # Early exit if no games
    - no_games_guard:
        switch:
          - condition: ${ len(games) == 0 }
            steps:
              - done_none:
                  return: ${"No games for team " + string(team_id) + " on " + date_str}

    # ------------------ Loop over games ------------------
    - loop_init:
        assign:
          - i: 0
          - n: ${len(games)}
    - loop_check:
        switch:
          - condition: ${ i >= n }
            next: done_all
        next: per_game

    # ------------------ Per-game: wait -> +90m -> poll ------------------
    - per_game:
        assign:
          - g: ${games[i]}
          - game_pk: ${g.gamePk}
          - start_utc: ${g.gameDate} # RFC3339 UTC
          - attempts: 0
          - max_attempts: 48 # 48 * 15min = 12h
          - g: null

    - sleep_until_start:
        call: sys.sleep_until
        args:
          time: ${start_utc}

    - buffer_90m:
        call: sys.sleep
        args:
          seconds: 5400

    # ------------ Poll status until FINAL (or cap) ------------
    - poll_status:
        call: http.get
        args:
          url: https://statsapi.mlb.com/api/v1/schedule
          query:
            sportId: "1"
            teamId: ${string(team_id)}
            date: ${date_str}
        result: sched_poll

    - extract_status:
        assign:
          - _games: []
          - abstract: ""
          - detailed: ""
    - maybe_set_games_from_poll:
        switch:
          - condition: ${ len(sched_poll.body.dates) > 0 }
            steps:
              - set_polled_games:
                  assign:
                    - _games: ${sched_poll.body.dates[0].games}
    - match_and_fill_status:
        assign:
          - found: false
          - j: 0
          - m: ${ len(_games) }
    - find_match_guard:
        switch:
          - condition: ${ j >= m }
            next: free_poll_payloads
        next: check_candidate
    - check_candidate:
        assign:
          - gg: ${ _games[j] }
    - maybe_take:
        switch:
          - condition: ${ gg.gamePk == game_pk }
            steps:
              - set_fields:
                  assign:
                    - abstract: ${ text.to_lower(string(gg.status.abstractGameState)) }
                    - detailed: ${ text.to_lower(string(gg.status.detailedState)) }
                    - found: true
        next: advance_loop
    - advance_loop:
        assign:
          - j: ${ j + 1 }
          - gg: null
        next: stop_if_found
    - stop_if_found:
        switch:
          - condition: ${ found }
            next: free_poll_payloads
        next: find_match_guard
    - free_poll_payloads:
        assign:
          - _games: null
          - sched_poll: null

    - final_status_check:
        switch:
          - condition: ${ abstract == "final" or detailed == "final" }
            next: run_ingest
        next: not_final_yet

    # ------------------ When FINAL: ingest -> sleep -> digest -> finish ------------------
    - run_ingest:
        call: googleapis.run.v2.projects.locations.jobs.run
        args:
          name: ${"projects/" + project_id + "/locations/" + region + "/jobs/mlb-ingest"}
          body:
            overrides:
              containerOverrides:
                - args: ${["--team", string(team_id), "--date", date_str]}
        result: ingest_exec
    - sleep_before_digest:
        call: sys.sleep
        args:
          seconds: 120
    - run_digest:
        call: googleapis.run.v2.projects.locations.jobs.run
        args:
          name: ${"projects/" + project_id + "/locations/" + region + "/jobs/mlb-digest"}
          body:
            overrides:
              containerOverrides:
                - args: ${["--team", string(team_id), "--date", date_str]}
        result: digest_exec
    - next_game_after_final:
        assign:
          - i: ${i + 1}
        next: loop_check

    # ------------------ Not final: sleep 15m, retry/cap ------------------
    - not_final_yet:
        call: sys.sleep
        args:
          seconds: 900
    - incr_attempts:
        assign:
          - attempts: ${attempts + 1}
    - cap_or_retry:
        switch:
          - condition: ${ attempts >= max_attempts }
            steps:
              - log_cap:
                  call: sys.log
                  args:
                    text: ${"Max attempts reached for game " + string(game_pk) + " on " + date_str}
              - advance_game:
                  assign:
                    - i: ${i + 1}
              - after_cap:
                  next: loop_check
        next: poll_status

    # ------------------ Done ------------------
    - done_all:
        return: ${"Done for team " + string(team_id) + " on " + date_str}
